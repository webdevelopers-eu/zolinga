<?php

declare(strict_types=1);

namespace Zolinga\System\Events;

use Zolinga\System\Types\{StatusEnum, SeverityEnum, OriginEnum};
use JsonSerializable;

/**
 * System event class.
 * 
 * If you want to implement stoppable events then extend the class and use StoppableInterface and StoppableTrait.
 * 
 * @property-read StatusEnum $status status code like OK, ERROR, NOT_FOUND, UNAUTHORIZED, FORBIDDEN, BAD_REQUEST, UNDETERMINED
 * @property-read string $message human readable status message
 * @property-read string $statusName status code name like "UNDETERMINED" or "FORBIDDEN" or "OK"
 * @property-read string $statusNiceName human readable status name like "Undetermined" or "Forbidden" or "Not Found" or "OK"
 */
class Event implements JsonSerializable
{
    /**
     * Unique Event identifier. It is generated by the coonstructor
     * but can be overriden if needed. Can be used by gates 
     * between Javascript and PHP and for other purposes.
     *
     * @var string
     */
    public $uuid;

    /**
     * Event type in the format of an URI. Example: example.org:api:myEvent
     *
     * @var string
     */
    public readonly string $type;

    /**
     * Origin of the event. Can be internal, remote or cli.
     * Note it is an enum and not a string so to access the value use $event->origin->value.
     *
     * @var OriginEnum
     */
    public readonly OriginEnum $origin;

    /**
     * Status of the event.
     * 
     * Note it is an enum and not a string so to access the value use $event->status->value.
     * 
     * This property is publicly readable by the magic method __get() 
     * but it is writeable only by the setStatus() method.   
     *
     * @var StatusEnum 
     */
    private StatusEnum $status = StatusEnum::UNDETERMINED;

    /**
     * Status message. It is a human readable message that describes the status of the event.
     * 
     * This property is publicly readable by the magic method __get() 
     * but it is writeable only by the setStatus() method.   
     *
     * @var ?string
     */
    private ?string $message = null;

    // Just shortcuts to the enums. It may be easier to use $event::STATUS_OK instead of importing enums... 
    final const STATUS_ERROR = StatusEnum::ERROR;
    final const STATUS_NOT_FOUND = StatusEnum::NOT_FOUND;
    final const STATUS_OK = StatusEnum::OK;

    final const STATUS_MULTIPLE_CHOICES = StatusEnum::MULTIPLE_CHOICES;
    final const STATUS_MOVED_PERMANENTLY = StatusEnum::MOVED_PERMANENTLY;
    final const STATUS_FOUND = StatusEnum::FOUND;
    final const STATUS_SEE_OTHER = StatusEnum::SEE_OTHER;
    final const STATUS_NOT_MODIFIED = StatusEnum::NOT_MODIFIED;
    final const STATUS_TEMPORARY_REDIRECT = StatusEnum::TEMPORARY_REDIRECT;
    final const STATUS_PERMANENT_REDIRECT = StatusEnum::PERMANENT_REDIRECT;

    final const STATUS_UNAUTHORIZED = StatusEnum::UNAUTHORIZED;
    final const STATUS_FORBIDDEN = StatusEnum::FORBIDDEN;
    final const STATUS_BAD_REQUEST = StatusEnum::BAD_REQUEST;
    final const STATUS_UNDETERMINED = StatusEnum::UNDETERMINED;
    final const STATUS_CONTINUE = StatusEnum::CONTINUE;
    final const STATUS_PROCESSING = StatusEnum::PROCESSING;
    final const STATUS_TIMEOUT = StatusEnum::TIMEOUT;
    final const STATUS_CONFLICT = StatusEnum::CONFLICT;
    final const STATUS_PRECONDITION_FAILED = StatusEnum::PRECONDITION_FAILED;
    final const STATUS_I_AM_A_TEAPOT = StatusEnum::I_AM_A_TEAPOT;
    final const STATUS_LOCKED = StatusEnum::LOCKED;


    final const ORIGIN_INTERNAL = OriginEnum::INTERNAL;
    final const ORIGIN_REMOTE = OriginEnum::REMOTE;
    final const ORIGIN_CLI = OriginEnum::CLI;
    final const ORIGIN_ANY = OriginEnum::ANY;

    public function __construct(string $type, OriginEnum $origin)
    {
        $this->type = $type;
        $this->origin = $origin;
        $this->uuid = uniqid();
    }

    public function __get(string $name): mixed
    {
        switch ($name) {
            case 'status':
            case 'message':
                return $this->$name;

            case 'statusName':
                return $this->status->name;

            case 'statusNiceName':
                return $this->status->getFriendlyName();

            default:
                throw new \Exception("Property $name does not exist or is inaccessible on " . self::class);
        }
    }

    public function __set(string $name, mixed $value)
    {
        switch ($name) {
            case 'status':
            case 'message':
            case 'statusName':
                throw new \Exception("Property $name is read-only on " . self::class . ". Use setStatus() method instead.");

            default:
                throw new \Exception("Property $name does not exist or is inaccessible on " . self::class);
        }
    }

    /**
     * Shortcut to calling $api->dispatchEvent($event)
     *
     * @return self
     */
    public function dispatch(): self
    {
        global $api;
        $api->dispatchEvent($this);
        return $this;
    }

    /**
     * Set the status and status message of the event.
     * 
     * @param StatusEnum $status
     * @param string $message
     * @return StatusEnum current status. May not be the same as $status in case there is already a error status set.
     */
    final public function setStatus(StatusEnum $status, string $message): StatusEnum
    {
        // If event failed then allow overwriting the status only with another error or success status.
        // If the status is OK do not overwrite it. 
        //
        // The rationale is that many Listeners may fail but one may succeed and that is enough. 
        // E.g. if we request data 3 Listeners may not find them (404 status) but one may find them (200 status).
        if ($this->status == self::STATUS_UNDETERMINED || !$this->isOK()) {
            $this->status = $status;
            $this->message = $message;
        }
        return $this->status;
    }

    /**
     * Does the event originate from the trusted origin "internal" or "cli"?
     *
     * @return boolean
     */
    final public function isTrusted(): bool
    {
        return $this->origin == self::ORIGIN_INTERNAL || $this->origin == self::ORIGIN_CLI;
    }

    /**
     * Does the Event has the status === 200?
     *
     * @return boolean
     */
    final public function isOK(): bool
    {
        return $this->status == self::STATUS_OK;
    }

    public function __toString(): string
    {
        $tags = [];
        $tags[] = basename(str_replace("\\", "/", $this::class));
        $tags[] = $this->origin->value;
        $tags[] = strtolower($this->status->getFriendlyName())." {$this->status->value}";
        return $this->status->getEmoji() . " Event {$this->type} [" . implode(", ", $tags) . "]";
    }

    /**
     * Specify data which should be serialized to JSON
     *
     * @return array<string, mixed>
     */
    public function jsonSerialize(): mixed
    {
        return [
            "type" => $this->type,
            "origin" => $this->origin->value,
            "status" => $this->status->value,
            "message" => $this->message,
        ];
    }
}
